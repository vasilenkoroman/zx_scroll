diff --git a/pc_compressor/compressed_line.h b/pc_compressor/compressed_line.h
index 95b7ae2..b53687d 100644
--- a/pc_compressor/compressed_line.h
+++ b/pc_compressor/compressed_line.h
@@ -100,8 +100,6 @@ struct CompressedLine
     }
 
     ZxData data;
-    std::vector<Register16> inputRegisters;
-    std::vector<Register16> outputRegisters;
 
     int drawTicks = 0;
     bool isAltReg = false;
@@ -125,5 +123,11 @@ public:
     std::vector<uint8_t> getFirstCommands(int size) const;
 
     void serialize(std::vector<uint8_t>& vector) const;
+};
 
+template <int N>
+class CompressedLineWithRegisters: public CompressedLine
+{
+public:
+    std::array<Register16, N> inputRegisters;
 };
diff --git a/pc_compressor/main.cpp b/pc_compressor/main.cpp
index bcb710c..3dbff49 100644
--- a/pc_compressor/main.cpp
+++ b/pc_compressor/main.cpp
@@ -77,9 +77,10 @@ Register16* findRegister(std::array<Register16, N>& registers, const std::string
     return nullptr;
 }
 
+template <int N>
 struct CompressedData
 {
-    std::vector<CompressedLine> data;
+    std::vector<CompressedLineWithRegisters<N>> data;
     Register16 af{"af"};
 
 public:
@@ -228,14 +229,14 @@ int sameVerticalWorlds(uint8_t* buffer, int x, int y)
 template <int N>
 bool compressLine(
     const Context& context,
-    CompressedLine& result,
+    CompressedLineWithRegisters<N>& result,
     std::array<Register16, N>& registers,
     int x);
 
 template <int N>
 inline bool makeChoise(
     const Context& context,
-    CompressedLine& result,
+    CompressedLineWithRegisters<N>& result,
     std::array<Register16, N>& registers,
     int regIndex,
     uint16_t word,
@@ -277,8 +278,8 @@ uint16_t swapBytes(uint16_t word)
  * So, check thus transitive references and mark Register as used.
 */
 
-template <typename T>
-void updateTransitiveRegUsage(T& data)
+template <int N>
+void updateTransitiveRegUsage(std::vector<CompressedLineWithRegisters<N>>& data)
 {
     int size = data.size();
     for (int lineNum = 0; lineNum < data.size(); ++lineNum)
@@ -290,7 +291,7 @@ void updateTransitiveRegUsage(T& data)
         for (int j = 1; j <= 8; ++j)
         {
             int nextLineNum = (lineNum + j) % size;
-            CompressedLine& nextLine = data[nextLineNum];
+            auto& nextLine = data[nextLineNum];
 
             selfRegMask |= nextLine.selfRegMask;
             uint8_t additionalUsage = nextLine.regUseMask & ~selfRegMask;
@@ -306,10 +307,10 @@ void updateTransitiveRegUsage(T& data)
 template <int N>
 bool compressLineMain(
     const Context& context,
-    CompressedLine& line,
+    CompressedLineWithRegisters<N>& line,
     std::array<Register16, N>& registers)
 {
-    CompressedLine line1, line2;
+    CompressedLineWithRegisters<N> line1, line2;
     auto registers1 = registers;
     auto registers2 = registers;
 
@@ -324,24 +325,20 @@ bool compressLineMain(
     else
         line = line1;
 
-    for (const auto& reg16 : registers)
-        line.inputRegisters.push_back(reg16);
+    line.inputRegisters = registers;
 
     if (useSecondLine)
         registers = registers2;
     else
         registers = registers1;
 
-    for (const auto& reg16 : registers)
-        line.outputRegisters.push_back(reg16);
-
     return true;
 }
 
 template <int N>
 bool compressLine(
     const Context& context,
-    CompressedLine&  result,
+    CompressedLineWithRegisters<N>&  result,
     std::array<Register16, N>& registers,
     int x)
 {
@@ -434,13 +431,13 @@ bool compressLine(
         if (isChoised)
             continue;
 
-        CompressedLine choisedLine;
+        CompressedLineWithRegisters<N> choisedLine;
         auto chosedRegisters = registers;
         for (int regIndex = 0; regIndex < registers.size(); ++regIndex)
         {
             auto regCopy = registers;
 
-            CompressedLine newLine;
+            CompressedLineWithRegisters<N> newLine;
             newLine.isAltReg = result.isAltReg;
             newLine.regUseMask = result.regUseMask;
             newLine.selfRegMask = result.selfRegMask;
@@ -462,7 +459,7 @@ bool compressLine(
             {
                 auto regCopy = registers;
 				
-                CompressedLine newLine;
+                CompressedLineWithRegisters<N> newLine;
                 newLine.isAltReg = result.isAltReg;
                 newLine.regUseMask = result.regUseMask;
                 newLine.selfRegMask = result.selfRegMask;
@@ -491,20 +488,21 @@ bool compressLine(
     return true;
 }
 
-std::future<std::vector<CompressedLine>> compressLinesAsync(const Context& context, const std::vector<int>& lines)
+template <int N>
+std::future<std::vector<CompressedLineWithRegisters<N>>> compressLinesAsync(const Context& context, const std::vector<int>& lines)
 {
     return std::async(
         [context, lines]()
         {
             std::array<Register16, 3> registers = { Register16("bc"), Register16("de"), Register16("hl") };
-            std::vector<CompressedLine> result;
+            std::vector<CompressedLineWithRegisters<N>> result;
 
             for (const auto line : lines)
             {
                 Context ctx = context;
                 ctx.y = line;
 
-                CompressedLine line;
+                CompressedLineWithRegisters<N> line;
                 auto registers1 = registers;
                 compressLineMain(ctx, line, registers1);
                 result.push_back(line);
@@ -542,7 +540,8 @@ std::vector<bool> removeInvisibleColors(int flags, uint8_t* buffer, uint8_t* col
     return result;
 }
 
-CompressedData compressImageAsync(int flags, uint8_t* buffer, std::vector<bool>* maskColors, 
+template <int N>
+CompressedData<N> compressImageAsync(int flags, uint8_t* buffer, std::vector<bool>* maskColors, 
     std::vector<int>* sameBytesCount, int imageHeight)
 {
     CompressedData compressedData;
@@ -556,7 +555,7 @@ CompressedData compressImageAsync(int flags, uint8_t* buffer, std::vector<bool>*
     context.maskColor = maskColors;
     context.sameBytesCount = sameBytesCount;
 
-    std::vector<std::future<std::vector<CompressedLine>>> compressors(8);
+    std::vector<std::future<std::vector<CompressedLineWithRegisters<N>>>> compressors(8);
 
     for (int i = 0; i < 8; ++i)
     {
@@ -564,7 +563,7 @@ CompressedData compressImageAsync(int flags, uint8_t* buffer, std::vector<bool>*
         std::vector<int > lines;
         for (int y = 0; y < imageHeight; y += 8)
             lines.push_back(y + i);
-        compressors[i] = compressLinesAsync(context, lines);
+        compressors[i] = compressLinesAsync<N>(context, lines);
     }
     for (auto& compressor : compressors)
     {
@@ -631,8 +630,8 @@ std::vector<int> createSameBytesTable(int flags, const uint8_t* buffer,
     return result;
 }
 
-
-CompressedData compress(int flags, uint8_t* buffer, uint8_t* colorBuffer, int imageHeight)
+template <int N>
+CompressedData<N> compress(int flags, uint8_t* buffer, uint8_t* colorBuffer, int imageHeight)
 {
     // Detect the most common byte in image
     std::vector<int> bytesCount(256);
@@ -672,7 +671,7 @@ CompressedData compress(int flags, uint8_t* buffer, uint8_t* colorBuffer, int im
     std::vector<int> sameBytesCount = createSameBytesTable(flags, buffer, &maskColor, imageHeight);
 
 
-    CompressedData result = compressImageAsync(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
+    CompressedData result = compressImageAsync<N>(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
     if (!(flags & inverseColors))
         return result;
 
@@ -685,13 +684,13 @@ CompressedData compress(int flags, uint8_t* buffer, uint8_t* colorBuffer, int im
             int lineNum = y * 8;
 
             inversBlock(buffer, x, y);
-            auto candidateLeft = compressImageAsync(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
+            auto candidateLeft = compressImageAsync<N>(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
 
             inversBlock(buffer, x+1, y);
-            auto candidateBoth = compressImageAsync(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
+            auto candidateBoth = compressImageAsync<N>(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
 
             inversBlock(buffer, x, y);
-            auto candidateRight = compressImageAsync(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
+            auto candidateRight = compressImageAsync<N>(flags, buffer, &maskColor, &sameBytesCount, imageHeight);
             inversBlock(buffer, x + 1, y);
 
             const int resultTicks = result.ticks();
@@ -943,9 +942,10 @@ CompressedLine  compressRealtimeColorsLine(uint16_t* buffer, uint16_t* nextLine,
 }
 #endif
 
-CompressedLine  compressMultiColorsLine2(Context context)
+template <int N>
+CompressedLineWithRegisters<N>  compressMultiColorsLine2(Context context)
 {
-    CompressedLine result;
+    CompressedLineWithRegisters<N> result;
     static const int kLineLength = 224;
     static const int kBorderTime = kLineLength - 128;
     static const int kStackMovingTime = 27;
@@ -998,7 +998,8 @@ CompressedLine  compressMultiColorsLine2(Context context)
     return result;
 }
 
-CompressedData compressRealTimeColors(uint8_t* buffer, int imageHeight)
+template <int N>
+CompressedData<N> compressRealTimeColors(uint8_t* buffer, int imageHeight)
 {
     // TODO: fill it
     static const int generatedCodeAddress = 0;
@@ -1011,11 +1012,11 @@ CompressedData compressRealTimeColors(uint8_t* buffer, int imageHeight)
     std::vector<int> sameBytesCount = createSameBytesTable(context.flags, buffer, /*maskColors*/ nullptr, imageHeight);
     context.sameBytesCount = &sameBytesCount;
 
-    CompressedData compressedData;
+    CompressedData<N> compressedData;
     for (int y = 0; y < imageHeight; y ++)
     {
         context.y = y;
-        auto line = compressMultiColorsLine2(context);
+        auto line = compressMultiColorsLine2<N>(context);
         /*
         if (!success)
         {
@@ -1032,7 +1033,8 @@ CompressedData compressRealTimeColors(uint8_t* buffer, int imageHeight)
     return compressedData;
 }
 
-void calculateMulticolorTimings(const CompressedData& data, const CompressedData & colorData, int flags)
+template <int N>
+void calculateMulticolorTimings(const CompressedData<N>& data, const CompressedData<N>& colorData, int flags)
 {
     // Start drawing: color since line 0, rastr since line 128
     const int imageHeight = data.data.size();
@@ -1061,7 +1063,8 @@ void calculateMulticolorTimings(const CompressedData& data, const CompressedData
     }
 }
 
-CompressedData  compressColors(uint8_t* buffer, int imageHeight)
+template <int N>
+CompressedData<N>  compressColors(uint8_t* buffer, int imageHeight)
 {
     CompressedData compressedData;
     int flags = verticalCompressionL | interlineRegisters;
@@ -1078,7 +1081,7 @@ CompressedData  compressColors(uint8_t* buffer, int imageHeight)
         context.buffer = buffer;
         context.y = y;
         context.sameBytesCount = &sameBytesCount;
-        CompressedLine line;
+        CompressedLineWithRegisters<N> line;
         bool success = compressLineMain(context, line, registers);
         compressedData.data.push_back(line);
     }
@@ -1086,9 +1089,10 @@ CompressedData  compressColors(uint8_t* buffer, int imageHeight)
     return compressedData;
 }
 
-void interleaveData(CompressedData& data)
+template <int N>
+void interleaveData(CompressedData<N>& data)
 {
-    std::vector<CompressedLine> newData;
+    std::vector<CompressedLineWithRegisters<N>> newData;
     for (int i = 0; i < 8; ++i)
     {
         for (int y = 0; y < data.data.size(); y += 8)
@@ -1112,10 +1116,11 @@ struct JpIxDescriptor
 
 #pragma pack(pop)
 
+template <int N>
 void resolveJumpToNextBankInGap(
     uint16_t offset,
     std::vector<uint8_t>& serializedData,
-    const CompressedData& data,
+    const CompressedData<N>& data,
     std::vector<int> lineOffsetWithPreambula)
 {
     // resolve JP to the next bank in Gaps
@@ -1208,7 +1213,8 @@ int nextLineInBank(int line, int imageHeight)
         return line + 1;
 }
 
-int serializeMainData(const CompressedData& data, const std::string& inputFileName, uint16_t codeOffset, int flags)
+template <int N>
+int serializeMainData(const CompressedData<N>& data, const std::string& inputFileName, uint16_t codeOffset, int flags)
 {
     using namespace std;
     const int imageHeight = data.data.size();
diff --git a/zx_scroller/draw_image.asm b/zx_scroller/draw_image.asm
index e96adc4..472e189 100644
--- a/zx_scroller/draw_image.asm
+++ b/zx_scroller/draw_image.asm
@@ -122,9 +122,12 @@ draw_4_lines_and_rt_colors:
                 // total ticks: 134
 
 
-        MACRO draw_8_lines
+draw_8_lines
                 // hl - descriptor
                 // sp - destinatin screen address to draw
+
+                ld b,8
+.rep1:
                 ld a, (hl)                                      ; 7
                 ex af, af'                                      ; 4
                 inc l                                           ; 4
@@ -138,8 +141,10 @@ draw_4_lines_and_rt_colors:
                 ld ix, $ + 5                                    ; 14
                 jp hl                                           ; 4
                 exx                                             ; 4
+                djnz .rep1
+                jp iy
                 // total: 66
-        ENDM
+        
                 // total 66 ticks (15 bytes)
 
         MACRO draw_8_color_lines
@@ -229,7 +234,8 @@ draw_image_and_color
         ld bc, descriptors  + 128 * 2                  ; 10
         add hl, bc                                     ; 11
         ld sp, 16384 + 1024 * 2
-        .8 draw_8_lines
+        ld iy, $+7
+        jp draw_8_lines
 
 /*
         // ----------- draw colors (middle)
@@ -245,7 +251,8 @@ draw_image_and_color
         ld bc, descriptors + 64 * 2                    ; 10
         add hl, bc                                      ; 11
         ld sp, 16384 + 1024 * 4
-        .8 draw_8_lines
+        ld iy, $+7
+        jp draw_8_lines
 
 /*
         // ----------- draw colors (bottom)
@@ -261,7 +268,8 @@ draw_image_and_color
         ld bc, descriptors                              ; 10
         add hl, bc                                      ; 11
         ld sp, 16384 + 1024 * 6
-        .8 draw_8_lines
+        ld iy, $+7
+        jp draw_8_lines
 
         ld sp, (stack_bottom)
         ret                
@@ -386,7 +394,7 @@ ticks_to_wait equ sync_tick - ticks_after_interrupt
 
 max_scroll_offset equ (timings_data_end - timings_data) / 2 - 1
 
-        ld bc, 0h                       ; 10  ticks
+        ld bc, 95h                       ; 10  ticks
         jp .loop
 .lower_limit_reached:
         ld bc,  max_scroll_offset       ; 10 ticks
