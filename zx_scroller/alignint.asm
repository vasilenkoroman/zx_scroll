;
;  align ver.0.3	copyright (c) 2013 introspec
;
;  this function aligns the execution to a 4 tact boundary and also computes (approximately)
;  the number of tacts in the frame (actually, number of tacts divided by 8 modulo 256).
;
;  после вызова этой функции исполнение программы оказывается выровненным до границы в 4 такта
;  (но, внимание, см. комментарий перед RET). в регистре C возвращается число тактов в кадре минус
;  107, делёное на 8 и взятое по модулю 256. работоспособность не гарантируется если эту
;  программу (или её стек) разместить в медленной памяти (что м.б. актуально на любой классике).
;  при вызове на скорпионе функция устанавливает флаг C.
;
;  общая идея этой процедуры сродственна процедуре Alone Coder'a (см. приложение к ZX-Guide #3),
;  но реализованный алгоритм, вообще говоря, новый.
;
;  главные достоинства новой реализации: более понятный код (субъективно), сопоставимый по длине
;  код (объективно), полноценная поддержка скорпиона (объективно), плюс, ценный бонус -
;  сравнительно точное измерение продолжительности фрейма и потенциал несложной доработки для
;  точного (до 4-х тактов) определения продолжительности фрейма (конечно, по модулю 256).
;
;  главный недостаток: более долгая работа цикла (до 12 фреймов). возможно сделать вариант этой
;  процедуры с фиксированным временем исполнения (4 фрейма). кроме того, мне кажется, что тут
;  остался ещё некоторый потенциал по дальнейшей оптимизации по длине.
;	

			MODULE	AlignInt

DoItAgain:	ei				; 4t
			xor	a			; 4t

MeasuringLoop:
			inc	a			; 4t
			jp	(hl)		; 4t

;
;  идея данного алгоритма следующая: мы крутимся в цикле из 8 тактов пока не наступит прерывание.
;  когда прерывание наступает, мы смотрим на младший бит адреса где нас прервали. нас интересует
;  ситуация, когда в прошлые разы прерывание происходило на одной из 4-х тактовых команд, а вот
;  сейчас произойдёт уже на другой. поэтому мы отстаём каждый фрейм на 1 такт, вдвигаем младшие биты
;  полученных адресов в регистр B и ждём, пока B не окажется заполненным 10001000 или 01110111.
;
;  эта логика не работает на скорпионе, т.к. он всегда подравнивает исполнение нашего цикла из 4-х
;  тактных команд до чётного числа тактов, а также добавляет задержки, указанные в квадратных скобках.
;  тем не менее, число тактов в обработчике прерывания подогнано так, чтобы скорпион оказывался
;  на границе двух команд каждый второй такт, что позволяет опознать его по значению 10101010 или
;  01010101 в регистре B. так как число тактов на скорпионе 69888, как и на классике, выравнивание
;  на 0 можно опознать по младшему биту адреса последней выровненной команды.
;  

			; точка входа обработчика прерывания (+19t int +10t[+1] jp)
IntEntry:	ld	c, a				; 4t
			pop	af					; 10t	(AF = MeasuringLoop или AF = MeasuringLoop+1; флаг C - младший бит адреса)
			sbc	a					; 4t	(флаг C (т.е. младший бит адреса) заполняет A)
			rl	b					; 8t	(младший бит адреса нужно вдвинуть в регистр B)
			xor	b					; 4t	(аккумулятор теперь содержит В, инвертированное если младший бит B был 1, т.е. младший бит всегда 0)
			cp	%10001000			; 7t	(так выглядит нулевой сдвиг)
			jp	z, NormalAligned	; 10t[+1]
			dec	d			; 4t
			jr	nz, TestScorp		; 12t

			inc	d					; nz is used to say "unrecognized pattern"
			ret

TestScorp:		ld	a, b			; 4t	(на скорпионе приходится смотреть напрямую на адреса)
			IF	MeasuringLoop and 1
			cp	%10101010			; 7t
			ELSE
			cp	%01010101			; 7t
			ENDIF
			jr	nz, DoItAgain		; 12t[+1]
							; от прерывания до следующей итерации получается 19+10 + 4+10+4+8+4+7+10+4+12 + 4+7+12 + 4+4 = 123 тактов
							; т.е. всякий раз мы сдвигаемся на один такт назад (на скорпионе - сдвигаемся на 2 такта вперёд)
ScorpionAligned:	scf				; 4t[+1]
			; мы на скорпионе и выполнили 19+(10+1)+4+10+4+8+4+7+(10+1)+4+7+(7+1)+(4+1) = 102 такта, плюс 2 такта сдвига.

NormalAligned:		; мы на машине без задержек и выполнили 19+10+4+10+4+8+4+7+10 = 76 тактов

			; в обоих случаях мы выровнены на границу в 4 такта.
			; команда RET имеет продолжительность 10 тактов, поэтому иногда м.б. удобно добавить ещё 2 такта для компенсации.
			;inc	hl
PrevHandler:		;ld	hl, 0
			ret

; в принципе, можно посмотреть на младший бит регистра B и получить результат в C
; с точностью до 4 тактов (т.е., вообще говоря, с идеальной точностью).
; в данный момент меня больше беспокоит не точность измерения, а компактность полученного кода.

; у 48к классики в кадре 69888 тактов => D ~ (69888-123)/8 mod 256 = #11
; жёлтый скорпион возвращает установленным флаг C, а округлённое кол-во кадров остаёся как у 48к
; у зелёных скорпионов в кадре 70784 тактов => (70784-123)/8 mod 256 = #81
; у 128к классики в кадре 70908 тактов => D ~ (70908-123)/8 mod 256 = #90
; у пентагона в кадре 71680 тактов => D ~ (71680-123)/8 mod 256 = #F1

; фактические результаты в эмуляторе могут отличаться на 1, что связано с общим кол-вом тактов в цикле.

			ENDMODULE

